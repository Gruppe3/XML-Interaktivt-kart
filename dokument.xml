<?xml version="1.0"?>
<standard><kapittel tittel=" General introduction">
	<seksjon tittel="Introduction">
		<p>SIMULA is a general purpose programming language. It inherits the algorithmic properties of ALGOL 60 and introduces methods for structuring data. 
			The main characteristic of SIMULA is that it is easily modelled towards specialized problem areas, and hence can be used as a basis for Special Application Languages.
		</p>
		<p>In this Standard the name SIMULA is considered synonymous with SIMULA 67. Although there exists a predecessor, SIMULA I, this latter language has achieved limited use.
			It is recommended that the language defined in this Standard be referred to as "Standard SIMULA".
		</p>
		<p>SIMULA includes most of the ALGOL 60 language. Wherever ALGOL is used in this Standard it relates to the STANDARD ALGOL 60 definition (ISO 1538).</p>
	</seksjon>
	
	<seksjon tittel="Scope and field of application">
		<p>This Standard establishes the definition of the programming language SIMULA and specifies conformity rules to related products, such as programs and processors.
			Its purpose is to facilitate interchange and promote portability of SIMULA programs between data processing systems.
		</p>
		<p>This Standard specifies:</p>
		<liste indeks="alfa">
			<indeks>The syntax, semantics and representation of SIMULA,</indeks>
			<indeks>Characteristics of processors (see 4.2.1) and their accompanying documents, and of SIMULA programs, required for conformity to this Standard,</indeks>
			<indeks>What is left to the discretion of the implementor, or to be specified for each implementation.</indeks>
		</liste>
		<p>This Standard does not specify:</p>
		<liste indeks="alfa">
			<indeks>Results or issues that are explicitly left undefined or said to be undefined,</indeks>
			<indeks>How non-valid programs are to be rejected and how this will be reported,</indeks>
			<indeks>The relationship of the hypothetical computer, used to explain the actions which constitute the elaboration of a program, to an actual data processing system.</indeks>
		</liste>
	</seksjon>
	
	<seksjon tittel="REFERENCES">
		<p>
			ISO 646-1973: The 7-bit coded character set for information processing interchange.
			ISO 1538-1984: Programming languages - ALGOL 60
			ISO 2022-1982: ISO 7-bit and 8-bit coded character sets
		</p>
		<p>"Common Base Language" by O.-J. Dahl, B. Myhrhaug and K. Nygaard Norwegian Computing Center 1984. (ISBN 82-539-0225-5)</p>
	</seksjon>
	
	<seksjon tittel="DEFINITIONS">
		<p>For the purpose of this Standard the following definitions apply.</p>
		<tabell>
			<rad>
				<kol>Note:</kol>
				<kol>
					Several terms used in this Standard are explained at the appropriate place in Part II (Description of the language). 
					For convenience some of these have been included here too, at times with a simplified definition. 
					It is understood, however, that no difference of meaning is considered to exist, and all definitions of a term are equivalent.
				</kol>
			</rad>
		</tabell>
		
		<avsnitt tittel="SIMULA Program">
		
		<p tittel="Potential program:">
			A text, that is a sequence of characters or typographical marks, meant
			to be a sequence of tokens constituting a SIMULA program.
		</p>
		
		
		<p tittel="Valid program:">
			A potential program that is a program according to the rules in this
			Standard.
		</p>
		
		
		<p tittel="Non-valid program:">
			A potential program that is not a program but can be turned into one
			by deleting or inserting a number of symbols.
		</p>
		
		
		<p tittel="Elaboration of a program:">
			A sequence of actions specified by the semantics to be carried out.
		</p>
	
		
		<p tittel="SIMULA program:">
			A valid program whose elaboration is defined by this Standard for
			an indicated class of input data.
		</p>
		
		</avsnitt>
		
		<avsnitt tittel="SIMULA Processors">
			
				<p tittel="Processor:">
					A compiler, translator or interpreter, in combination with a data
					processing system, that accepts a potential program, transcribed
					in a form that can be processed by that data processing system,
					reports whether the potential program is valid or not, and if so
					requested is able to execute it, if it has not
					rejected it.
				</p>
			
		</avsnitt>
		
		<avsnitt tittel="SIMULA Implementations">
			
			<p tittel="Implementation:">
				A well-documented processor is said to establish an implementation
				of the language SIMULA.
			</p>
			
			
			<p tittel="Implemented language:">
				The version of the language defined by the implementation.
			</p>
			
			
			<p tittel="Extension:">
					A rule in the implemented language that
				
				<liste inedeks="alfa">is not given in this Standard
					<indeks>
						does not cause any ambiguity when added to this Standard
						(but may serve to remove a restriction)
					</indeks>
					<indeks>is within the scope of this Standard.</indeks>
				</liste>
			</p>
			
			<p tittel="Implementation-defined:">
				 What is to be specified for each implementation.
			</p>
			
			
			<p tittel="Implementation-dependent:">
				What is left to the discretion of the implementor.
			</p>
		</avsnitt>
	</seksjon>
	
	<seksjon tittel="CONFORMITY">
		<avsnitt tittel="Requirements">
			<p tittel="Conforming programs">
				Conformity to this Standard requires for a program that
			</p>
			<liste indeks="alfa">
				<indeks>it shall be a SIMULA program</indeks>
				<indeks>a set of input data shall be given for which it has a defined meaning.</indeks>
			</liste>
			<p tittel="Conforming processors">
				Conformity to this Standard requires for a processor that
			</p>
			<liste indeks="alfa">
				<indeks>it shall accept valid programs as being valid,</indeks>
				<indeks>it shall reject non-valid programs as being non-valid,</indeks>
				<indeks>it shall not elaborate a SIMULA program differently from what is defined in this Standard,</indeks>
				<indeks>it shall be accompanied by documents complying with the requirements below.</indeks>
			</liste>
			<p tittel="Documentation">
				It is required for the documents accompanying a conforming processor that these shall
				describe clearly
			</p>
			<liste indeks="alfa">
				<indeks>its purpose, the name of the implemented language, if not SIMULA, and the environment (hardware and software) in which it will work,</indeks>
				<indeks>its intended properties, including</indeks>
				<liste indeks="tegn">
					<indeks>the actions taken when results or issues occur, left undefined in this Standard,</indeks>
					<indeks>conventions for issues said to be implementation-defined,</indeks>
					<indeks>what is provided for issues declared to be implementation dependent,</indeks>
				</liste>
				<indeks>all differences between the implemented language and the language defined in Part II of this Standard,</indeks>
				<indeks>its logical structure,</indeks>
				<indeks>the way to put it into use.</indeks>
			</liste>
			<p tittel="Conforming implementations">
				 A conforming implementation shall comply with the above requirements for a processor
				and its accompanying documents.
			</p>
		</avsnitt>
		
		<avsnitt tittel="Quantitative restrictions">
			<p>
				The requirements specified in 4.1 shall allow for quantitative restrictions to rules
				stated or implied as having no such restriction in this Standard, but only if they are
				fully described in the documents with the implementation. These restrictions are to be
				considered implementation-defined in as far as they are not dependent of any momentary
				resource restraint during execution of a program.
			</p>
		</avsnitt>
		
		<avsnitt tittel="Extensions">
			<p>
				An implementation that allows for extensions in the implemented language is considered
				to conform to this Standard, notwithstanding 4.1 if
			</p>
			<liste indeks="alfa">
				<indeks>it would be conforming when the extensions were omitted,</indeks>
				<indeks>those extensions are clearly described with the implementation,</indeks>
				<indeks>while accepting programs that are non-valid according to the rules
					given in Part II of this Standard, it provides means for indicating
					which part, or parts, of a program would have led to its rejection,
					had no extensions been allowed (cf. Part II, ch. 16),
				</indeks>
				<indeks>the implemented language is a super-language of SIMULA.</indeks>
			</liste>
			<p>
				Extensions are allowed only if the following conditions are fulfilled:
			</p>
			<liste indeks="alfa">
				<indeks>
					The implementor provides a translator program, which takes
					any program accepted by that implementation and translates
					it into a valid program. The resulting program may contain
					a minimum of calls to non-SIMULA procedures in cases where
					this is absolutely necessary due to a lack of facilities
					in the language.
				</indeks>
				<indeks>
					Each implementation has a switch which must be set to make
					the compiler accept programs with extensions.
				</indeks>
			</liste>
			<p> 
				An implementation which allows extensions, shall give
				warning messages for the use of such extensions.
			</p>
			<p>
				Valid programs using extensions shall be described as "conforming
				to the SIMULA Standard but for the following indicated parts".
			</p>
		</avsnitt>
		
		<avsnitt tittel="Subsets">
			<p>This Standard does not include subsets.</p>
		</avsnitt>
	</seksjon>
	
	<seksjon tittel="TESTS">
		<p>
			Whether an implementation is a conforming implementation may possibly be
			detected by a suite of test programs. If there is any uncertainty or doubt
			regarding acceptance of these programs then the conclusion drawn from the
			actual behavior of the processor will prevail over those derived from its
			accompanying documents.
		</p>
	</seksjon>
	
	<seksjon tittel="APPENDICES">
		<p>Appendices contained within this document are not part of this Standard.</p>
	</seksjon>
</kapittel><kapittel tittel="Chapter 1 - LEXICAL TOKENS">
  <seksjon tittel="Definitional Conventions">
    <p>
    The meta language used in this standard to 
    specify the syntax of the constructs is based 
    on the Backus-Naur Form. The meanings of the 
    various meta symbols are listed in the table 
    below. Further (semantic) specifications of the 
    constructs are given in prose and, in some cases, 
    by equivalent program fragments. In such program 
    fragments some identifiers introduced by 
    declarations are printed in upper case. The use 
    of upper case letters signifies that the 
    identifier in question represents some quantity 
    which is inaccessible to a program. An example of 
    this convention is the identifier EVENT_NOTICE of 
    chapter 12. Any other identifier that is defined e
    lsewhere in the standard will denote the 
    corresponding entity by its occurrence in such a 
    program fragment.
    </p>
    
    <p>
      <syntaks>
        <produksjon>
          <alternativ>Note:</alternativ> 
          <alternativ>The use of program fragments as described above, 
          as well as the description of standard facilities 
          (see chapters 8-12) by algorithmic means should be 
            taken as definitive only as far as their effect is 
          concerned. An actual implementation should seek to 
          produce these effects in as efficient a manner as 
          practicable. Furthermore, when arithmetic of real 
          type is concerned, even the effects must be regarded 
          as defined with only a finite degree of accuracy (
          see 3.5.3).
          </alternativ>
        </produksjon>
      </syntaks>
    </p>
    
    <p>
      <produksjon>
        <tabell>
        <rad>
          <kol>Metasymbol</kol>
          <kol>Meaning</kol>
        </rad>
        <rad>
          <kol/>  
          <kol/>
        </rad>
        <rad>               
          <kol>=</kol>
          <kol>is defined to be</kol>
        </rad>
        <rad>                  
          <kol>!</kol>
          <kol>alternatively</kol>
        </rad>
        <rad>                  
          <kol>[ x ]</kol>
          <kol>0 or 1 instance of x</kol>
        </rad>
        <rad>             
          <kol>{ x }</kol>
          <kol>0 or more instances of x</kol>
        </rad>
        <rad>  
          <kol>( x | y )</kol>
          <kol>grouping: either x or y</kol>
        </rad>
        <rad>          
          <kol>xyz</kol>
          <kol>the terminal symbol xyz</kol>
        </rad>
        <rad>       
          <kol>meta-identifier</kol>
          <kol>a non-terminal symbol</kol>
        </rad>
        <rad>   
          <kol>...</kol> 
          <kol>see below</kol>
        </rad>        
      </tabell>
    </produksjon>         
  </p>  
    
    
    <p>
     A meta-identifier is a sequence of letters, 
     digits and hyphens beginning with a letter. 
     The identifier has intentionally been chosen 
     to convey a hint of its meaning to the reader. 
     The exact meaning is, however, defined by its 
     (single) occurrence on the left hand side of a 
     production. When used outside productions these 
     identifiers are generally written with spaces 
     instead of hyphens, except in cases where 
     possible ambiguities might result.
    </p>
    
    <p>
    A few productions contain the ellipsis (...) as a 
    right hand side. In such cases a prose explanation 
    is given immediately below the production.
    </p>
    
    <p>
    A sequence of terminal and non-terminal symbols in a 
    production implies concatenation of the text that they 
    ultimately represent. Within chapter 1 this concatenation 
    is direct; no characters may intervene. In the remainder 
    of the Standard the concatenation is in accordance with 
    the rules set out in this chapter.
    </p>
    
    <p>
    The characters required to form SIMULA programs are those 
    explicitly classified as "basic" in the table given in 
    section 1.2. Additional characters of that table may be 
    employed as described in that section.
    </p>
    
    <p>
    A SIMULA source module consists of directive lines and 
    program lines. Apart from 1.1 this standard is not 
    concerned with directive lines. The lexical tokens 
    used to construct program lines are classified into 
    special symbols, identifiers, unsigned numbers, simple 
    strings and character constants.
    </p>
    
    <p>
    No lexical token may consist of more than 72 characters.
    </p>
    <p>
    <syntaks>
      <produksjon>  
       <term>letter</term>
         <alternativ>=  A | B | C | D | E | F | G | H | I
         |  J | K | L | M | N | O | P | Q | R
         |  S | T | U | V | W | X | Y | Z
         |  a | b | c | d | e | f | g | h | i
         |  j | k | l | m | n | o | p | q | r
         |  s | t | u | v | w | x | y | z
         </alternativ>
      </produksjon>
    </syntaks>
    </p>  
    <p>
    The representation of any letter (upper or lower case, 
    differences in font, etc.) occurring anywhere other than 
    in a simple string or a character constant has no 
    significance in that occurrence for the meaning of 
    the program.
    </p>
    <p>
      <syntaks>
        <produksjon>        
          <term>digit</term>
            <alternativ>= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</alternativ>
          <term>space</term>
            <alternativ>=  SP</alternativ>
        </produksjon>
      </syntaks>
    </p> 
      
    <p>
    SP is the space (blank) character (ISO 646 code 2/0).
    </p>
    
  </seksjon>
  <seksjon tittel="Directive lines">
  
    <p>
    If the first character of a line is "%" (percent) 
    the line as a whole is a directive line.
    </p>
    
    <p>
    A directive line serves to communicate information to the 
    processor and consequently its meaning is entirely 
    implementation-dependent, with the following single exception. 
    If the second character is a space, the line has no significance; 
    it may be used for annotation purposes.
    </p>
    
    <p>
      <syntaks>
        <produksjon>
          <term>Note:</term>
            <alternativ>
                    The interpretation of a directive line takes precedence over the 
                    treatment of subsequent lines.
                    The interpretation by the processor may cause inclusion of 
                    lines not present in the module, or deletion of some lines 
                    actually following the directive in question.
          </alternativ>
      </produksjon>
    </syntaks>
    </p>
    
    <p>
     The language defined in the following defines the resulting program 
     text after all directive lines have been interpreted and thereafter deleted.
    </p>
    
  </seksjon>
  <seksjon tittel="The character set">
  
    <p>
      The standard presupposes an 8-bit internal representation of characters. 
      ISO 2022). Thus the isocode facility allows for inclusion of characters 
      with "isorank" value greater than 127 in simple strings and character 
      constants. An implementation may restrict this possibility as well as 
      the character set given below, as long as the "basic" characters of the 
      table are included.
    </p>
    
    <p>
    The standard character set is defined by the table below. For each 
    character its "isorank" (see 9.2), name or printable representation 
    and the classification of the character as a program text 
    constituent are given.
    </p>
    
    <p>
      <produksjon>
        <tabell>
          <rad>
            <kol>basic:</kol>    
            <kol>Significant in all contexts.</kol>
          </rad>
          <rad>
            <kol>skip:</kol>     
            <kol>Skipped in all contexts.</kol>
          </rad>
          <rad>
            <kol>graphic:</kol>  
            <kol>Significant inside comments, inside simple strings, and inside
            character constants; illegal outside these constructs.</kol>
         </rad>
         <rad>
            <kol>national:</kol> 
            <kol>Reserved for national alphabet extension; treated as "graphic".</kol>
         </rad>
         <rad>
            <kol>format:</kol>   
            <kol>Format effector, see 1.9.</kol>
        </rad>
      </tabell>
     </produksjon> 
    </p>
    <p>
      <produksjon>
        <tabell>
          <rad>      
               <kol>0</kol> 
               <kol>NUL</kol>  
               <kol>skip</kol>        
               <kol>32</kol>  
               <kol>SP</kol>  
               <kol>basic</kol>       
               <kol>64</kol>      
               <kol>national</kol>    
               <kol>96</kol>      
               <kol>national</kol>
           </rad>
           <rad>    
                <kol>1</kol> 
                <kol>SOH</kol>  
                <kol>illegal</kol>     
                <kol>33 </kol> 
                <kol>! </kol>  
                <kol>basic </kol>      
                <kol>65</kol>  
                <kol>A  </kol> 
                <kol>basic</kol>       
                <kol>97</kol>  
                <kol>a</kol>   
                <kol>basic </kol>
          </rad>
          <rad>
                <kol>2</kol> 
                <kol>STX</kol>  
                <kol>illegal</kol>     
                <kol>34 </kol> 
                <kol>"  </kol> 
                <kol>basic </kol>      
                <kol>66</kol>  
                <kol>B </kol>  
                <kol>basic</kol>       
                <kol>98</kol>  
                <kol>b </kol>  
                <kol>basic</kol>
          </rad>
          <rad>
                <kol>3</kol> 
                <kol>ETX</kol>  
                <kol>illegal</kol>     
                <kol>35</kol> 
                <kol>#</kol>   
                <kol>graphic</kol>     
                <kol>67</kol>  
                <kol>C</kol>   
                <kol>basic</kol>       
                <kol>99</kol>  
                <kol>c</kol>   
                <kol>basic</kol>
          </rad>
          <rad>
                <kol>4</kol> 
                <kol>EOT</kol>  
                <kol>illegal</kol>     
                <kol>36</kol>  
                <kol>$</kol>   
                <kol>graphic</kol>     
                <kol>68</kol>  
                <kol>D</kol>   
                <kol>basic</kol>      
                <kol>100</kol>  
                <kol>d</kol>   
                <kol>basic</kol>
          </rad>
          <rad>
                <kol>5</kol> 
                <kol>ENQ</kol>  
                <kol>illegal</kol>     
                <kol>37</kol>  
                <kol>%</kol>   
                <kol>graphic</kol>     
                <kol>69</kol>  
                <kol>E</kol>  
                <kol>basic</kol>      
                <kol>101</kol>  
                <kol>e</kol>   
                <kol>basic</kol>
          </rad>
          <rad>
                <kol>6</kol> 
                <kol>ACK</kol>  
                <kol>illegal</kol>     
                <kol>38</kol>  
                <kol>&amp; </kol>  
                <kol>basic </kol>      
                <kol>70</kol>  
                <kol>F</kol>   
                <kol>basic</kol>      
                <kol>102</kol>  
                <kol>f</kol>   
                <kol>basic</kol>
          </rad>
          <rad>
                <kol>7</kol> 
                <kol>BEL</kol>  
                <kol>illegal</kol>     
                <kol>39</kol>  
                <kol>'</kol>   
                <kol>basic</kol>       
                <kol>71</kol>  
                <kol>G</kol>   
                <kol>basic</kol>      
                <kol>103</kol>  
                <kol>g</kol>   
                <kol>basic</kol>
          </rad>
        </tabell>
      </produksjon>
    </p>
    
  
    
    <p>
    Table 1.1. Standard character set
    (International Reference Version)
    </p>

  </seksjon>
  <seksjon tittel="Special Symbols">
  <p>
    <produksjon>
      <tabell>
        <rad>
         <kol>+   -   *   /   //  **</kol>      
         <kol>Arithmetic operators</kol>
       </rad>
       <rad>
         <kol>&amp;</kol>                          
         <kol>Text concatenation operator, or exp. mark</kol>
        </rad>
       <rad> 
         <kol>&amp;&amp;</kol>                         
         <kol>Exponent mark in long real numbers</kol>
       </rad>
       <rad>  
         <kol>:=  :- </kol>                     
        <kol> Assignment operators</kol>
       </rad>
       <rad>  
         <kol>&lt;   &lt;=  =   &gt;=  &gt;   &lt;&gt;</kol>      
         <kol>Value relational operators</kol>
       </rad>
       <rad>  
         <kol>==  =/= </kol>                    
         <kol>Reference relational operators</kol>
       </rad>
       <rad>  
         <kol>'</kol>                           
         <kol>Character quote</kol>
       </rad>
       <rad>  
         <kol>"   ""</kol>                      
         <kol>String quote ("" only within strings)</kol>
       </rad>
       <rad>  
         <kol>!</kol>                           
         <kol>Code quote, or comment</kol>
       </rad>
       <rad>  
         <kol>; </kol>                          
         <kol>Statement separator, or
         declaration or specification delimiter</kol>
       </rad>
       <rad>                              
         <kol>:</kol>                           
         <kol>Array bounds separator, or
         label definition or virtual delimiter</kol>
        </rad>
       <rad> 
         <kol>(   )</kol>                       
         <kol>Parameter, array bounds grouping, or expr.</kol>
       </rad>
       <rad>  
         <kol>.</kol>                          
         <kol>Remote indicator ("dot"), or decimal mark</kol>
       </rad>
       <rad>  
        <kol> ,</kol>                           
         <kol>Parameter, array bounds pair or expression
                                     separator</kol> 
                           
        </rad>                             
       </tabell>                              
     </produksjon>                                
  </p>
  <p>
  Table 1.2. Special symbols, excluding key words
  </p>
  
  <p>
  Normally the syntax of the language assumes that all syntactic 
  units are recognised as being the largest possible string of 
  characters which fits the syntax of a symbol. However, in an 
  array declaration the symbol ":" is always a bounds separator, 
  even if it is immediately followed by a minus.
  </p> 
  <p>   
    <produksjon>
      <tabell>
        <rad>
         <kol>activate</kol>    
         <kol>else</kol>        
         <kol>if</kol>          
         <kol>none</kol>        
         <kol>short</kol>
        </rad> 
        <rad> 
         <kol>after</kol>       
         <kol>end</kol>         
         <kol>imp</kol>         
         <kol>not</kol>         
         <kol>step</kol>
        </rad> 
        <rad>         
         <kol>and</kol>         
         <kol>eq</kol>          
         <kol>in</kol>          
         <kol>notext</kol>      
         <kol>switch</kol>
        </rad> 
        <rad>         
         <kol>array</kol>       
         <kol>eqv</kol>         
         <kol>inner</kol>
         <kol/>
         <kol/>
        </rad> 
        <rad>         
         <kol>at</kol>          
         <kol>external</kol>    
         <kol>inspect</kol>     
         <kol>or</kol>          
         <kol>text</kol>
        </rad> 
        <rad>         
         <kol/>
         <kol/>                        
         <kol>integer</kol>     
         <kol>otherwise</kol>   
         <kol>then</kol>
        </rad> 
        <rad>         
         <kol>before</kol>      
         <kol>false</kol>       
         <kol>is</kol>          
         <kol/>            
         <kol>this</kol>
        </rad> 
        <rad>         
         <kol>begin</kol>       
         <kol>for</kol>         
         <kol/>            
         <kol>prior </kol>     
         <kol>to</kol>
        </rad> 
        <rad>          
         <kol>boolean</kol>     
         <kol/>            
         <kol>labe</kol>       
         <kol>procedure </kol>  
         <kol>true</kol>
        </rad> 
        <rad>         
         <kol/>            
         <kol>ge</kol>          
         <kol>le</kol>          
         <kol>protected</kol>
         <kol/>
        </rad> 
        <rad>         
         <kol>character</kol>   
         <kol>go</kol>          
         <kol>long</kol>        
         <kol/>            
         <kol>until</kol>
        </rad> 
        <rad>         
         <kol>class </kol>      
         <kol>goto </kol>       
         <kol>lt</kol>         
         <kol>qua</kol>
         <kol/>
        </rad> 
        <rad>         
         <kol>comment</kol>     
         <kol>gt</kol>         
         <kol/>            
         <kol/>             
         <kol>value</kol>
        </rad> 
        <rad>         
         <kol/>
         <kol/>
         <kol>name</kol>        
         <kol>reactivate</kol>  
         <kol>virtual</kol>
        </rad> 
        <rad>         
         <kol>delay</kol>       
         <kol>hidden</kol>      
         <kol>ne</kol>          
         <kol>real</kol>
         <kol/>
         </rad> 
        <rad>        
         <kol>do</kol>         
         <kol/>             
         <kol>new</kol>         
         <kol>ref</kol>         
         <kol>when</kol>
        </rad> 
        <rad>         
         <kol/>
         <kol/>
         <kol/>
         <kol/>
         <kol>while</kol>
       </rad>                                                       
      </tabell>
    </produksjon>
  </p>
  <p>
  Table 1.3. SIMULA key words
  </p>
  
  <p>
    <syntaks>
      <produksjon>
        <term>Note:</term>
          <alternativ>For typographical reasons, the standard key words may, 
                      within this Standard, be printed as indicated in table 1.3. 
                      Within a program, the key words are printed as identifiers 
                      (cfr. letter production above).
          </alternativ>
      </produksjon>
    </syntaks>
  </p>
  
  </seksjon>
  <seksjon tittel="Identifiers">
  <p>
    <syntaks>
      <produksjon>
        <term>identifier</term>
        <alternativ>=  letter  { letter  |  digit  |  _ }</alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>
  No identifier can have the same spelling as any key word. 
  Apart from this, identifiers may be chosen freely. They 
  have no inherent meaning, but serve for the identification 
  of language quantities i.e. simple variables, arrays, texts, 
  labels, switches, procedures, classes and class attributes. 
  Within a procedure declaration identifiers also act as formal 
  parameters, in which capacity they may represent a literal 
  value or any language quantity except a class. All constituent 
  characters are significant in distinguishing between identifiers.
  </p>
  
  </seksjon>
  <seksjon tittel="Numbers">
  <p>
    <syntaks>
      <produksjon>
        <term>unsigned-number</term>
         <alternativ>=  decimal-number  [ exponent-part ]</alternativ>
         <alternativ>|  exponent-part</alternativ>

        <term>decimal-number</term>
         <alternativ>=  unsigned-integer  [ decimal-fraction ]</alternativ>
         <alternativ>|  decimal-fraction</alternativ>

        <term>decimal-fraction</term>
         <alternativ>=  .  unsigned-integer</alternativ>

        <term>exponent-part</term>
         <alternativ>=  ( &amp; | &amp;&amp; )  [ + | - ]  unsigned-integer</alternativ>

        <term>unsigned-integer</term>
         <alternativ>=  digit  { digit | _ }</alternativ>
         <alternativ>|  radix R radix-digit { radix-digit | _ }</alternativ>

        <term>radix</term>
         <alternativ>=  2 | 4 | 8 | 16</alternativ>

        <term>radix-digit</term>
         <alternativ>=  digit | A | B | C | D | E | F </alternativ>
      </produksjon>
    </syntaks>
  </p>

  
  <p>
  Decimal numbers have their conventional meaning. 
  The exponent part is a scale factor expressed as an integral power of 10.
  </p>
  
  <p>
   Unsigned integers are normally expressed in decimal digits. 
   Unsigned integers of radix 2, 4, 8, or 16 may be expressed as shown. 
   The radix digits A through F express radix 16 digits 10 through 15 
   (decimal). The radix determines the legality and the interpretation 
   of a radix digit in an obvious manner.
  </p>
  
  <p>
  An unsigned number which is an unsigned integer is of type integer. 
  Otherwise, if an unsigned number contains an exponent part with a double 
  ampersand () it is of type long real, else it is of type real.
  </p>
  
  <p>
  Examples
  </p>
  <p>
    <syntaks>
      <produksjon>
        <alternativ>2&amp;1    2.0&amp;+1   .2&amp;2   20.0   200&amp;-1   - represent same <b>real</b> value (20.0)</alternativ>
        <alternativ>2.345_678&amp;&amp;0                           - <b>long</b> <b>real</b> value (2.345678)</alternativ>
      </produksjon>
    </syntaks>
  </p>
  </seksjon>
  <seksjon tittel="Strings">
  <p>
    <syntaks>
      <produksjon>
        <term>string</term>
         <alternativ>
            =  simple-string { string-separator simple-string }
         </alternativ>

        <term>string-separator</term>
         <alternativ>
            =  token-separator  { token-separator }
         </alternativ>

        <term>simple-string</term>
         <alternativ>
            =  " { ISO-code | non-quote-character | "" } "
         </alternativ>

        <term>ISO-code</term>
         <alternativ>
            =  !  digit  [ digit ]  [ digit ]  !
         </alternativ>

        <term>non-quote-character</term>
         <alternativ>
            =  ...
        </alternativ>
      </produksjon>
    </syntaks>
  </p>
  
  <p>
  A non-quote-character is
    <punkt>
      <indeks>
          any printing character (incl. space) except the string 
          qoute ". Such a character represents itself.
      </indeks>
    </punkt>
  </p>
  
  <p>
  A simple string must be contained within a single program line. 
  Long strings are included as a sequence of simple strings 
  separated by token separators.
  </p>
  
  <p>
  In order to include a complete 8-bit coded character set, 
  any character may be represented within a string by an integer, 
  its isocode, corresponding to its bit combination. An isocode 
  cannot consist of more than three digits, and it must be less 
  than 256. If these conditions are not satisfied, the construction 
  is interpreted as a character sequence. The string quote may, 
  however, also be represented in simple strings by two consecutive 
  quotes (see the last example below). Observe that, as a consequence 
  of the definitional conventions given earlier in this chapter, 
  no spaces may intervene between such a pair of string quotes.
  </p>
  
  <p>
  Examples
  </p>
  <p>
    <produksjon>
      <tabell>
        <rad>
                <kol>The string:</kol>               
                <kol>represents:</kol>
        </rad>
        <rad>
                <kol>"Ab"  "cde"</kol>               
                <kol>Abcde</kol>
          </rad>
        <rad>      
                <kol>"AB"  "CDE"  ABCDE</kol>
                <kol/>
           </rad>
        <rad>     
                <kol>"!2!ABCDE!3!"</kol>             
                <kol>ABCDE enclosed by STX and ETX</kol>
            </rad>
        <rad>    
                <kol>"!2" "!ABCDE!" "3!"</kol>       
                <kol>!2!ABCDE!3!</kol>
           </rad>
        <rad>     
                <kol>"AB"" C""DE"</kol>             
                <kol>AB" C"DE</kol>
                 
        </rad>
      </tabell>
    </produksjon>
  </p>  
  </seksjon>
  
  <seksjon tittel="Character constants">
  <p>
    <syntaks>
      <produksjon>
        <term>character-constant</term>
         <alternativ>=  '  character-designator  ' </alternativ>
 
        <term>character-designator</term>
         <alternativ>=  ISO-code</alternativ>
         <alternativ>|  non-quote-character</alternativ>
         <alternativ>|  "</alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>       
  A character constant is either a single printing character 
  or it is an ISO-code - in both cases surrounded by character 
  quotes (' - ISO 646 code 2/7).
  </p>
  <p>
  Within the data processing system, characters are represented by 
  values according to some implementation-defined code. This 
  code also defines the collating sequence used when comparing 
  character (and text) values by means of relational operators.
  </p>
  </seksjon>
  
  <seksjon tittel="Comment convention">
  <p>
  For the purpose of annotating the program proper comments may be included 
  in a program. The substitution of end for an end-comment, or a space for a 
  direct comment does not alter the meaning of a program.
  </p>
  <p>
    <syntaks>
      <produksjon>
        <alternativ>Note:</alternativ>
        <alternativ>As a consequence of 1.8.1 and 1.8.2 comments cannot be nested. It is understood that the 
                    comment structure encountered first in a program when reading from left to right 
                    has precedence in being replaced over later structures contained by the sequence.
        </alternativ>
      </produksjon>
    </syntaks>
  </p>
  
  <avsnitt tittel="End comment">
  <p>
  The key word end may be followed by any sequence of characters and separation 
  of lines not containing any of the special symbols <b>end</b>, <b>else</b>, <b>when</b>, <b>otherwise</b>, 
  or ";". This sequence (excluding the delimiting special symbol, but including 
  the initial end) constitutes an end-comment.
  </p>
  </avsnitt>
  
  <avsnitt tittel="Direct comment">
  <p>
  The special symbol "!" (exclamation mark) followed by any sequence of characters 
  or separation of lines not containing ";" (semicolon), and delimited by semicolon, 
  is treated as a comment if the exclamation mark does not occur within a character 
  constant or a simple string (in which cases it may either represent itself or act 
  as a code quote), or within a comment.
  </p>
  <p>
    <syntaks>
      <produksjon>
        <alternativ>Note:</alternativ>
        <alternativ>The delimiting semicolon is considered part of a direct comment and 
        thus takes part in the substitution.</alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>Example</p>
  <p>
    <syntaks>
      <produksjon>
        <alternativ>if B then begin ... end !then; else ...
        </alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>is not valid since the ! is part of an end-comment. Thus ";" will act as a 
  statement separator (and no statement can start with else).</p>
  </avsnitt>
  </seksjon>
  <seksjon tittel="Token Seperators">
  <p>
    <syntaks>
      <produksjon>
        <term>format-effector </term>
         <alternativ> =  BS  |  HT  |  LF  |  VT  |  FF  |  CR </alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>BS, HT, LF, VT, FF, and CR represent the characters thus named in 
    table 1.3. A format effector in general acts as a space. In addition, 
    an implementation may define some additional action to be taken (such 
    as tabulation when listing the program); such action has no significance 
    for the meaning of the program
  </p>
  <p>
    <syntaks>
      <produksjon>
        <term>token-separator</term>
        <alternativ> =  ... </alternativ>
      </produksjon>
    </syntaks>
  </p>
  <p>
      A token-separator is
  </p>
  <p>
    <punkt>
      <indeks>a direct comment, or</indeks>
      <indeks>a space (except in simple strings and character constants), or</indeks>
      <indeks>a format effector (except as noted for spaces), or</indeks>
      <indeks>the separation of consecutive lines.</indeks>
    </punkt>
  </p>
  <p>
     Zero or more token separators may occur between any two consecutive 
     tokens, or before the first token of a program text. At least one 
     token separator must occur between any pair of consecutive tokens made 
     up of identifiers, key words, simple strings or unsigned numbers. 
     No token separators may occur within tokens.
  </p>
  </seksjon>
  <seksjon tittel="Program interchange and lexical alternatives">
   <p>In order to ease portability of SIMULA programs, a common representation has 
   been adopted for the language. This representation is used throughout this 
   standard except for the following conventions adopted for typographical reasons:
   </p>
   <p>
    <produksjon>
      <punkt>In order to emphasise the use of the language keywords, 
          these are printed in a special manner.
      </punkt>
      <punkt>Identifiers printed in upper case within this document represent 
          quantities which are inaccessible to the user. Such identifiers are used 
          for definitional purposes, they may or may not have actual counterparts 
          in an implementation of the language.
      </punkt>
      <punkt>Program fragments may contain the ellipsis (...) instead of valid 
          constructs, where it is either obvious from the context what the 
          construct should be or the intended meaning cannot be expressed in 
          a simple manner within the language.
      </punkt>
    </produksjon>
  </p>
<avsnitt tittel="Alternate representation of some symbols">
  <p>The representation for lexical tokens and separators given in 1.2 
    to 1.9 constitutes a standard representation for these tokens and separators. 
    This standard representation is recommended for program interchange.</p>
  <p>For historical reasons the following alternatives have been defined. 
    All processors that have the required characters in their character set 
    must provide both the standard and the alternate representations, and 
    there is no distinction made between corresponding tokens or separators.
    </p>
    <p>The alternate representations for the tokens are</p>
	<p>
    <produksjon>
      <tabell>
        <rad>
          <kol>standard token</kol>
          <kol>kole representation</kol>
        </rad>
        <rad>  
          <kol/>   
          <kol/>
        </rad>
        <rad>   
          <kol>&lt;</kol>
          <kol>lt</kol>
        </rad>
        <rad>                   
          <kol>&lt;=</kol>
          <kol>le=</kol>
         </rad>
        <rad>                     
          <kol>=&lt;</kol>
          <kol>eq</kol>
        </rad>
        <rad>                      
          <kol>&gt;=</kol>
          <kol>ge</kol>
        </rad>
        <rad>                     
          <kol>&gt;</kol>
          <kol>gt</kol>
        </rad>
        <rad>                     
          <kol>&lt;&gt;</kol>
          <kol>ne</kol>
        </rad>
        <rad>                     
          <kol>!</kol>
          <kol>comment</kol>
        </rad>
      </tabell>
    </produksjon>                  
  </p>               
  </avsnitt>
  </seksjon>
</kapittel><kapittel tittel=" STATEMENTS">
<pre>
    statement
        =  { label : }  unconditional-statement
        |  { label : }  conditional-statement
        |  { label : }  for-statement

    unconditional-statement
        =  assignment-statement
        |  while-statement
        |  goto-statement
        |  procedure-statement
        |  object-generator
        |  connection-statement
        |  compound-statement
        |  block
        |  dummy-statement
        |  activation-statement
</pre>
<p>The units of operation within the language are called
statements. They are normally executed consecutively as
written. The sequence of operations may for instance be
broken by goto-statements, which define their successor
explicitly, or by sequencing procedure calls, which define
their successor implicitly. It may be shortened by
conditional statements, which may cause certain statements
to be skipped. It may be lengthened by for-statements and
while-statements which cause certain statements to be
repeated.</p>

<p>In order to make it possible to define an explicit dynamic
succession, statements may be provided with labels.</p>

<p>Since sequences of statements may be grouped together into
compound statements and blocks the definition of statement
must necessarily be recursive. Also since declarations,
described in chapter 5, enter fundamentally into the
syntactic structure, the syntactic definition of statements
must suppose declarations to be already defined.</p>
<seksjon tittel="Assignment statements">
<pre>
    assignment-statement
        =  value-assignment
        |  reference-assignment

    value-assignment
        =  value-left-part  :=  value-right-part

    value-left-part
        =  destination
        |  simple-text-expression

    value-right-part
        =  value-expression
        |  text-expression
        |  value-assignment

    destination
        =  variable
        |  procedure-identifier

    reference-assignment
        =  reference-left-part  :-  reference-right-part

    reference-left-part
        =  destination

    reference-right-part
        =  reference-expression
        |  reference-assignment
</pre>
<p>Assignment statements serve for assigning the value of an
expression to one or several destinations. Assignment to a
procedure identifier may only occur within the body of a
procedure defining the value of the function designator
denoted by that identifier. If assignment is made to a
subscripted variable, the values of all the subscripts must
lie within the appropriate subscript bounds, otherwise a
run-time error will result.</p>

<p>The operator := (read: "becomes") indicates the assignment
of a value to the value type variable or value type
procedure identifier which is the left part of the value
assignment or the assignment of a text value to the text
frame referenced by the left part.</p>

<p>The operator :- (read: "denotes") indicates the assignment
of a reference to the reference type variable or reference
type procedure identifier which is the left part of the
reference assignment.</p>

<p>A procedure identifier in this context designates a memory
device local to the procedure instance. This memory device
is initialised upon procedure entry following the rules
given in 5.7. The type associated with a procedure
identifier is given as the first symbol of the
corresponding procedure declaration.</p>

<p>The value or reference assigned is a (suitably converted)
representation of the one obtained by evaluating the right
part of the assignment. If the right part is itself an
assignment, the value or reference obtained is a copy of
its constituent left part after that assignment operation
has been completed.</p>

<p>The process is in the general case understood to take place in three steps as follows:</p>
<liste indeks="alfa">
  <indeks>Any expression which is, or is part of, the left part of
    an assignment is evaluated prior to the evaluation of
    the right part. Within a particular left part,
    constituent expressions such as subscript expressions
    are evaluated in sequence from left to right.</indeks>

  <indeks>The expression of the ultimate right part is evaluated.</indeks>

  <indeks>The value or reference of this expression is assigned to
    its immediately preceding left part. If the left part is
    itself part of an assignment, the resulting value or
    reference is assigned to its immediately preceding left
    part. The process is repeated until the left part list
    is exhausted. All assignments are performed with any
    left part expression having values as evaluated in (a).</indeks>
</liste>
<p><b>Note</b>: It is not required that, in multiple assignments, all
      left parts are of the same type, as long as the
      appropriate type conversion functions are defined.</p>

<p>If the destination is of type <b>Boolean</b> or <b>character</b>, the
value right part must likewise be of type <b>Boolean</b> or
<b>character</b>, respectively.</p>

<p>For the description of the text value assignment, see
4.1.2. There is no value assignment operation for objects.</p>

<p>The type of the value or reference obtained by evaluating
the right part must coincide with or be subordinate to the
type of the left part, with the exceptions mentioned in the
following sections.</p>

<p>If a destination is a formal parameter called by name, and
the type of the corresponding actual parameter does not
coincide with that of the formal specification, then the
assignment operation is carried out in two steps.</p>
<liste indeks="num">
  <indeks>An assignment is made to a fictitious variable of the
    type specified for the formal parameter.</indeks>

  <indeks>An assignment statement is executed whose left part is
    the actual parameter and whose right part is the
    fictitious variable.</indeks>
</liste>
<p>The value or reference obtained by evaluating the
assignment is, in this case, that of the fictitious
variable.</p>

<avsnitt tittel="Arithmetic assignment">

<p>If the type of the arithmetic expression differs from that
associated with the destinations, an appropriate conversion
function is understood to be automatically invoked. For
transfer from real to integer type the conversion function
is understood to yield a result which is the largest
integral quantity not exceeding E + 0.5 in the mathematical
sense (i.e. without rounding error) where E is the value of
the expression.</p>

<p>Conversion from <b>integer</b> to <b>short</b> <b>integer</b> is exact within
the value range of <b>short</b> <b>integer</b>; outside it constitutes a
run-time error. Conversion from <b>long</b> <b>real</b> to <b>real</b> is
performed with correct rounding. If the value range of
<b>long</b> <b>real</b> exceeds that of <b>real</b> a run-time error may result.</p>

<p>Conversions not mentioned above are performed according to
the rules given in 3.5.1.</p>

<p><b>Note</b>: The value of a real type expression is defined with
      only finite accuracy.</p>

<p><b>Note</b>: Consider the statement "X:= i:= Y:= F:= 3.14" where X
      and Y are <b>real</b> variables, i is an <b>integer</b> variable,
      and F is a formal parameter called by name and
      specified <b>real</b>.  If the actual parameter for F is a
      <b>real</b> variable, then X, i, Y and F are given the
      values 3, 3, 3.14 and 3.14 respectively. If the
      actual parameter is an <b>integer</b> variable, the
      respective values are 3, 3, 3.14 and 3.</p>
</avsnitt>
<avsnitt tittel="Text value assignment">

	<p>Let X be the text variable identified as the result of
		evaluating the left part (see 3.7) of a text value
		assignment, and let Y denote the text variable identified
		by evaluating the corresponding right part. If X references
		a constant text frame, or X.LENGTH &lt; Y.LENGTH, then the
		assignment constitutes an error. Otherwise, the value of Y
		is conceptually extended to the right by X.LENGTH -
		Y.LENGTH blank characters, and the resulting text value is
		assigned as the new contents of the text frame referenced
		by X.
	</p>
		
<p><b>Note</b>: If X==<b>notext</b>, the assignment is legal if and only if
      Y==<b>notext</b>. The effect on X of the assignment "X := Y"
      is equivalent to that of "X := copy(Y)", regardless
      of whether or not X and Y overlap.</p>

<p>The position indicators of the left and the right parts are
ignored and remain unchanged.</p>

<p>If X and Y are non-overlapping texts of the same length
then, after the evaluation of the value assignment "X:= Y",
the relation "X=Y" is true.</p>

<p>A text procedure identifier occurring as a value left part
within the procedure body is interpreted as a text
variable. The corresponding assignment statement thus
implies an assignment to the local procedure identifier.</p>
</avsnitt>

<avsnitt tittel="Text reference assignment">

<p>Let X be the text variable which constitutes the left part
of a text reference assignment, and let Y denote the
variable identified by evaluating the corresponding right
part. The effect of the assignment is defined as the four
component assignments:</p>
<pre>
      X.OBJ    :- Y.OBJ;      X.START  := Y.START;
      X.LENGTH := Y.LENGTH;   X.POS    := Y.POS;
</pre>
</avsnitt>
<avsnitt tittel="Object reference assignment">

<p>Let the left part of an object reference assignment be qualified by the class
Cl, and let the right part be qualified by Cr. If the right part is itself a
reference assignment, Cr is defined as the qualification of its constituent
left part. Let V be the value obtained by evaluating the right part. The
legality and effect of the reference assignment depend on relationships between
Cr, Cl and V.</p>
<pre>
Case 1.  
	Cl is the class Cr or outer to Cr:
	The reference assignment is legal and the
	assignment operation is carried out.
Case 2.  
	Cl is inner to Cr:
	The reference assignment is legal. The
	assignment operation is carried out if V is
	<b>none</b> or is an object belonging to the class Cl
	or a class inner to Cl. If not, the execution
	of the reference assignment constitutes a
	run-time error.
Case 3.
	Cl and Cr satisfy neither of these relations:
	The reference assignment is illegal.
</pre>
<p>Similar rules apply to reference assignments implicit in
for-clauses and the transmission of parameters.</p>

<p><b>Example</b></p>

<p>Let "point" and "polar" be the classes declared in the
example of 5.5.2.</p>
<pre>
     <b>ref</b> (point) p1, p2; <b>ref</b> (polar) p3;
     p1:- <b>new</b> polar (3,4); p2:- <b>new</b> point (5,6);
</pre>
<p>Now the statement "p3:-p1" assigns to p3 a reference to
the "polar" object which is the value of p1. The statement
"p3:-p2" would cause a run-time error.</p>
</avsnitt>
</seksjon>

<seksjon tittel="Conditional statement">
<pre>
    conditional-statement
        =  if-clause { label : } unconditional-statement
           [ <keyword>else</keyword> statement ]
        |  if-clause { label : } for-statement

    if-clause
        =  <keyword>if</keyword>  Boolean-expression  <keyword>then</keyword>
</pre>
<p>Conditional statements cause certain statements to be
executed or skipped depending on the running values of
specified Boolean expressions.</p>

<p>Three forms of the conditional statement exist. Let B be a
Boolean expression, Su an unconditional statement, Sfor a
for-statement and S a statement. Then, in execution of a
statement of the form  "<keyword>if</keyword> B <keyword>then</keyword> Su", B is evaluated.
If the result is true, Su is executed. If the result is
false, Su is not executed. If Su is labelled, and a
goto-statement leads to the label, then B is not evaluated,
and the computation continues with execution of the
labelled statement.</p>

<p>The two remaining forms are explained in terms of the
above, as follows.</p>
<pre>
The conditional statement:   is equivalent to:

<b>if</b> B <b>then</b> Sfor               <b>if</b> B <b>then</b> <b>begin</b> Sfor <b>end</b>

<b>if</b>    B                      <b>if</b> B
<b>then</b>  Su                     <b>then</b> <b>begin</b> Su; <b>goto</b> GAMMA  <b>end</b>;
<b>else</b>  S                      S;
                             GAMMA: ...
</pre>
<p>If Su, Sfor or S are labelled they are labelled in the
equivalent construct.</p>

<p><b>Note</b>: The effect of a goto-statement leading into a
      conditional statement follows directly from the above
      explanation of the execution of a conditional
      statement.</p>

<p><b>Examples</b></p>
<pre>
         <b>if</b> x&gt;0 <b>then</b> n:=n+1

         <b>if</b> <b>false</b> <b>then</b> abort: terminate_program
         <b>else</b> <b>if</b> s&lt;0 <b>or</b> p&lt;q  <b>then</b>
         <b>else</b> <b>if</b> v&gt;s <b>then</b> a := v-q
         <b>else</b> <b>if</b> v&lt;s-1 <b>then</b> <b>goto</b> abort
</pre>
</seksjon>

<seksjon tittel="While-statement">
<pre>
    while-statement
        =  <b>while</b>  Boolean-expression  <b>do</b>  statement
</pre>
<p>A while-statement causes a statement to be executed zero or
more times.</p>

<p>The evaluation of "<b>while</b> BE <b>do</b> S" is equivalent to</p>
<pre>
     ALFA: <b>if</b>  BE  <b>then</b> <b>begin</b>  S;  <b>goto</b> ALFA  <b>end</b>
</pre>
</seksjon>

<seksjon tittel="For-statement">
<pre>
    for-statement
        =  for-clause  statement

    for-clause
        =  <b>for</b>  simple-variable  for-right-part  <b>do</b>

    simple-variable
        =  identifier

    for-right-part
        =  := value-for-list-element
           { , value-for-list-element }
        |  :- reference-for-list-element
           { , reference-for-list-element }

    value-for-list-element
        =  value-expression  [ <b>while</b> Boolean-expression ]
        |  text-expression
        |  arithmetic-expression <b>step</b> arithmetic-expression
           <b>until</b>  arithmetic-expression

    reference-for-list-element
        =  reference-expression
           [ <b>while</b>  Boolean-expression ]
</pre>
<p>The simple variable of the for-clause is called "the
controlled variable". The statement following is called
"the controlled statement".</p>

<p>A for-clause causes the controlled statement to be executed
repeatedly zero or more times. Each execution of the
controlled statement is preceded by an assignment to the
controlled variable and a test to determine whether this
particular for list element is exhausted.</p>

<p>Assignments may change the value of the controlled variable
during execution of the controlled statement. Upon exit
from the for-statement, the controlled variable has the
value given to it by the last (explicit or implicit)
assignment operation.</p>
<avsnitt tittel="For list elements">

<p>The for list elements are considered in the order in which
they are written. When one for list element is exhausted,
control proceeds to the next, until the last for list
element in the list has been exhausted. Execution then
continues after the controlled statement.</p>

<p>The effect of each type of for list element is defined
below using the following notation:</p>
<pre>
C:  
	controlled variable
V:  
	value expression
R:  
	reference expression
A:  
	arithmetic expression
B:  
	Boolean expression
S:  
	controlled statement
</pre>
<p>The effect of the occurrence of expressions as for list
elements may be established by textual replacement in the
definitions. ALFA and DELTA are considered local to the
fictitious block (4.4.3). DELTA is of the same type as A2.</p>
<pre>
  1. V (value expression)     C := V;
                              S;
                              ... next for list element

  2. A1 <b>step</b> A2 <b>until</b> A3      C     := A1;
                              DELTA := A2;
                              <b>while</b> DELTA*(C-A3) &lt;= 0
                                 <b>do</b> <b>begin</b>
                                    S;
                                    DELTA := A2;
                                    C     := C + DELTA;
                              <b>end</b> while;
                           ... next for list element

  3. V <b>while</b> B         ALFA:  C:= V;
                              <b>if</b> B <b>then</b> <b>begin</b>
                                 S;
                                 <b>goto</b> ALFA; <b>end</b>;
                              ... next for list element

  4. R (reference expression)    C :- R;
                                 S;
                                 ... next for list element

  5. R <b>while</b> B         ALFA:  C :- R;
                              <b>if</b> B <b>then</b> <b>begin</b>
                                 S;
                                 <b>goto</b> ALFA; <b>end</b>;
                              ... next for list element
</pre>
</avsnitt>

<avsnitt tittel="The controlled variable">
<p>The controlled variable cannot be a formal parameter called
by name, or a procedure identifier.</p>

<p>To be valid, all for list elements in a for-statement
(defined by textual substitution, see 4.4.1) must be
semantically and syntactically valid. In particular each
implied reference assignment in cases 4 and 5 of 4.4.1 is
subject to the rules of 4.1.4 and 4.1.3, and each text
value assignment in cases 1 and 3 of 4.4.1 is subject to
the rules of 4.1.2.</p>
</avsnitt>
<avsnitt tittel="The controlled statement">

<p>The controlled statement always acts as if it were a block,
whether it takes this form or not. Hence, labels on or
defined within the controlled statement are invisible
outside that statement.</p>
</avsnitt>
</seksjon>

<seksjon tittel="Goto-statement">
<pre>
    goto-statement
        =  ( <b>goto</b> | <b>go</b> <b>to</b> )  designational-expression
</pre>
<p>A goto-statement interrupts the normal sequence of
operations, by defining its successor explicitly by the
value of a designational expression (i.e. a program point).
Thus the next statement to be executed is the one at this
program point.</p>

<p>The program point referenced by the designational
expression must be visible at the goto-statement (cfr.
5.6.2).</p>

<p>See also 7.3.5.</p>

<p><b>Examples</b></p>
<pre>
         <b>goto</b>  L8
         <b>goto</b>  exit(n+1)
         <b>go</b> <b>to</b> Town(<b>if</b> y&lt;0 <b>then</b> N <b>else</b> N+1)
         <b>goto</b> <b>if</b> Ab&lt;c <b>then</b> L17
                <b>else</b> q(<b>if</b> w&lt;0 <b>then</b> 2 <b>else</b> n)
</pre>
</seksjon>

<seksjon tittel="Procedure statement">
<pre>
    procedure-statement
        =  procedure-identifier-1 [ actual-parameter-part ]
</pre>
<p>A procedure statement interrupts the normal sequence of
operations by invoking (calling for) the execution of a
procedure body. Conceptually this may be described in the
following terms.</p>

<p>If the procedure has parameters an additional block
embracing the procedure body block (cf. 5.4) is created.
All formal parameters correspond to variables declared in
this (fictitious) block with types as given in the
corresponding specifications. Thus formal parameters are
non-local to the procedure body, but local to this block.
The evaluation of the procedure statement now proceeds as
described in 4.6.5.</p>

<avsnitt tittel="Actual-formal parameter correspondence">

<p>The correspondence between the actual parameters of the
procedure statement and the formal parameters of the
procedure heading is established as follows. The actual
parameter list of the procedure statement must have the
same number of entries as the formal parameter list of the
procedure declaration heading. The correspondence is
obtained by taking the entries of these two lists in the
same order.</p>

<p>The type correspondence of formal and actual parameters is
governed by the following rules:</p>
<liste indeks="tegn">
<indeks>exact type correspondence is required for parameters of
   type <b>text</b>, <b>character</b> or <b>Boolean</b> as well as for all <b>array</b>
   parameters, irrespective of transmission mode</indeks>

<indeks>an actual parameter corresponding to a formal parameter
   of arithmetic type which is not an array or procedure can
   have any arithmetic type. The conversion follows the
   assignment statement rules for parameters called by value
   and by reference and 5.4.3 for parameters called by name</indeks>

<indeks>a type procedure can correspond to a formal parameter
   specified as a proper procedure</indeks>

<indeks>the type of an actual parameter corresponding to a formal
   parameter of object reference type must coincide with or
   be surordinate to the formal type (see 2.4.2).</indeks>
</liste>
</avsnitt>


<avsnitt tittel="Value parameter replacement (call by value)">

<p>A formal parameter called by value designates initially a
local copy of the value (or array) obtained by evaluating
the corresponding actual parameter.</p>

<p>All formal parameters quoted in the value part of the
procedure heading as well as value type parameters not
quoted in the name part are assigned the values of the
corresponding actual parameters, these assignments being
considered as performed explicitly before entering the
procedure body. The effect is as though an additional block
embracing the procedure body were created in which these
assignments were made to variables local to this fictitious
block with types as given in the corresponding
specifications (cf. 4.6.5). As a consequence, variables
called by value are to be considered as non-local to the
body of the procedure, but local to the fictitious block.</p>

<p><b>Note</b>: Parameters transmitted by value are evaluated once
      only, before entry of the procedure body.</p>

<p>A text parameter called by value is a local variable
initialised by the statement  "FP :- copy(AP)"  where FP is
the formal parameter, and AP is the variable identified by
evaluating the actual parameter. (:- is defined in 4.1.3,
and "copy" in 8.3).</p>

<p>Value specification is redundant for a parameter of value
type.</p>

<p>There is no call by value option for object reference type
parameters and reference type array parameters.</p>
</avsnitt>

<avsnitt tittel="Default parameter replacement (call by reference)">

<p>Any formal parameter which is not of value type and which
is not quoted in the mode part is said to be called by
reference.</p>

<p>A formal parameter called by reference is initially
assigned a local copy of the reference obtained by
evaluating the corresponding actual parameter. Such
assignments are entirely analogous to those described under
call by value.</p>

<p><b>Note</b>: Parameters transmitted by reference are evaluated
      once before entry of the procedure body.</p>

<p>A reference type formal parameter is a local variable
initialised by a reference assignment  "FP:- AP"  where FP
is the formal parameter and AP is the reference obtained by
evaluating the actual parameter. The reference assignment
is subject to the rules of 4.1.3 and 4.1.4. Since in this
case the formal parameter is a reference type variable, its
contents may be changed by reference assignments within the
procedure body.</p>

<p>Although array, procedure, label and switch identifiers do
not designate references to values, there is a strong
analogy between references in the strict sense and
references to entities such as arrays, procedures (i.e.
procedure declarations), program points and switches.
Therefore a call by reference mechanism is defined in these
cases.</p>

<p>An array, procedure, label or switch parameter called by
reference cannot be changed from within the procedure or
class body. It thus references the same entity throughout
its scope. However, the contents of an array called by
reference may well be changed through appropriate
assignments to its elements.</p>

<p>For a procedure parameter called by reference, the type
associated with the actual parameter must coincide with or
be subordinate to that of the formal specification.</p>
</avsnitt>

<avsnitt tittel="Name parameter replacement (call by name)">
<p>Call by name is an optional transmission mode available
only for parameters to procedures.</p>

<p>Each occurrence of a formal parameter called by name within
the procedure body invokes an evaluation of the actual
parameter. This evaluation takes place in the context of
the procedure statement, i.e. no identifier conflicts can
occur (since the procedure body and its variables are
invisible).</p>

<p>If the actual and formal parameters are of different
arithmetic types, then the appropriate type conversion must
take place, irrespective of the context of use of the
parameter.</p>

<p>For an expression within a procedure body which is</p>
<liste indeks="num">
<indeks>a formal parameter called by name,</indeks>

<indeks>a subscripted variable whose array identifier is a
    formal parameter called by name, or</indeks>

<indeks>a function designator whose procedure identifier is
    a formal parameter called by name,</indeks>
</liste>
<p>the following rules apply:</p>
<liste indeks="num">
<indeks>Its type is that prescribed by the corresponding formal
    specification.</indeks>

<indeks>If the type of the actual parameter does not coincide
    with that of the formal specification, then an
    evaluation of the expression is followed by an
    assignment of the value or reference obtained to a
    fictitious variable of the latter type. This assignment
    is subject to the rules of 4.1. The value or reference
    obtained by the evaluation is the contents of the
    fictitious variable.</indeks>
</liste>
<p>Also, for a formal text parameter called by name, the
following rule applies:</p>
<liste indeks="tegn">
<indeks>If the actual parameter is constant (i.e. CONST is
    _true_), then all occurrences of the formal parameter
    evaluate to the same text frame (see 3.7).</indeks>
</liste>
<p>Section 4.1 defines the meaning of an assignment to a
variable which is a formal parameter called by name, or is
a subscripted variable whose array identifier is a formal
parameter called by name, if the type of the actual
parameter does not coincide with that of the formal
specification.</p>

<p>Assignment to a procedure identifier which is a formal
parameter is illegal, regardless of its transmission mode.</p>

<p><b>Note</b>: Each dynamic occurrence of a formal parameter called
      by name, regardless of its kind, may invoke the
      execution of a non-trivial expression, e.g. if its
      actual parameter is a remote identifier, since the
      actual parameter is evaluated at each occurrence.</p>

</avsnitt>	  
	  
	  
<avsnitt tittel="Body execution">

<p>The execution of a procedure call proceeds in the following
steps, where 1 and 2 are performed only if the procedure
has parameters.</p>
<liste indeks="num">
<indeks>The formal parameter block instance is created.</indeks>

<indeks>Actual parameters corresponding to call by value or call
    by reference are evaluated as described above and the
    results are assigned to the corresponding variables of
    the formal block instance, following the rules in 4.1.
    Actual parameters corresponding to call by name are
    treated as described in 4.6.4.</indeks>

<indeks>The procedure body is instantiated and starts executing.</indeks>
</liste>
<p>The execution of the final statement of the procedure body,
unless this statement is itself a goto-statement, concludes
with the execution of an implicit goto-statement to the
program point immediately following the procedure
statement.</p>
</avsnitt>

<avsnitt tittel="Restrictions">

<p>For a procedure statement to be defined it is evidently
necessary that the operations on the procedure body defined
in section 4.6.5 lead to a correct statement. This imposes
the restriction on any procedure statement that the kind
and type of each actual parameter be compatible with the
kind and type of the corresponding formal parameter. The
following are some important particular cases of this
general rule, and some additional restrictions.</p>

<p>A formal parameter which occurs as a destination within the
procedure body and which is called by name can only
correspond to an actual parameter which is an
identification of a variable (special case of expression).</p>

<p>A formal parameter which is used within the procedure body
as an array identifier can only correspond to an actual
parameter which identifies an array of the same number of
dimensions. In addition if the formal parameter is called
by value the local array created during the call has the
same subscript bounds as the actual array. Similarly the
number, kind and type of any parameters of a formal
procedure parameter must be compatible with those of the
actual parameter.</p>

<p><b>Note</b>: The rules stated above are applicable only where
      formal arrays or procedure calls are actually
      evaluated during the execution of the procedure body.</p>
</avsnitt>
</seksjon>
	  
<seksjon tittel="Object generator statement">

<p>An object generator invokes the generation and execution of
an object belonging to the identified class. The object is
a new instance of the corresponding (concatenated) class
body. The evaluation of an object generator consists of the
following actions:</p>
<liste indeks="num">
<indeks>The object is generated and the actual parameters, if
    any, of the object generator are evaluated. The
    parameter values and/or references are transmitted.</indeks>

<indeks>Control enters the object through its initial <b>begin</b>
    whereby it becomes operating in the "attached" state
    (see chapter 7). The evaluation of the object generator
    is completed:</indeks>
</liste>
<pre>
case a:
	whenever the basic attribute procedure "detach" of the generated object is executed (see 7.1), or
case b:
	upon exit through the final <b>end</b> of the object .
</pre>

<p>The state of the object after the evaluation is either
"detached" (a) or "terminated" (b). Cf. chapter 7.</p>

<avsnitt tittel="Parameter replacement">

<p>In general the correspondence between actual and formal
parameters is the same for classes as for procedures.</p>

<p>The call by name option is not available for classes.
Procedure, label and switch parameters cannot be
transferred to classes.</p>

<p>For further information on the parameter transmission
modes, see 5.5.5.</p>
</avsnitt>
</seksjon>

<seksjon tittel="Connection statement">
<pre>
connection-statement
        =  <b>inspect</b> object-expression
           when-clause { when-clause } [ otherwise-clause ]
        |  <b>inspect</b> object-expression
           <b>do</b> connection-block-2 [ otherwise-clause ]

    when-clause
        =  <b>when</b> class-identifier <b>do</b> connection-block-1

    otherwise-clause
        =  <b>otherwise</b>  statement

    connection-block-1
        =  statement

    connection-block-2
        =  statement
</pre>
<p>A connection block may itself be or contain a connection
statement. This "inner" connection statement is then the
largest possible connection statement. Consider the
following:</p>
<pre>
    <b>inspect</b> A <b>when</b> A1 <b>do</b>
          <b>inspect</b> B <b>when</b> B1 <b>do</b> S1           *
                    <b>when</b> B2 <b>do</b> S2           *
                    <b>otherwise</b> S3;           *
</pre>
<p>The inner connection statement includes the lines that are
marked with an asterisk.</p>

<p>The purpose of the connection mechanism is to provide
implicit definitions to items 1 and 2 in 5.5.6 for certain
attribute identifications within connection blocks.</p>

<p>The execution of a connection statement may be described as
follows:</p>
<liste indeks="num">
<indeks>The object expression of the connection statement is
   evaluated. Let its value be X.</indeks>

<indeks>If when-clauses are present they are considered from left
   to right. If X is an object belonging to a class equal or
   inner to the one identified by a when-clause, the
   connection-block-1 of this when-clause is executed, and
   subsequent when-clauses are skipped. Otherwise, the
   when-clause is skipped.</indeks>

<indeks>If a connection-block-2 is present it is executed, unless
   X is <b>none</b> in which case the connection block is skipped.</indeks>

<indeks>The statement of an otherwise-clause is executed if X is
   <b>none</b>, or if X is an object not belonging to a class inner
   to the one identified by any when-clause. Otherwise it is
   skipped.</indeks>
</liste>
<p>A statement which is a connection-block-1 or a connection-
block-2 acts as a block, whether it takes the form of a
block or not. It further acts as if enclosed by a second
fictitious block, called a "connection block". During the
execution of a connection block the object X is said to be
"connected". A connection block has an associated "block
qualification", which is the preceding class identifier for
a connection-block-1 and the qualification of the preceding
object expression for a connection-block-2.</p>

<p>Let the block qualification of a given connection block be
C and let A be an attribute identifier, which is not a
label or switch identifier, defined at any prefix level of
C. Then any uncommitted occurrence of A within the
connection block is given the local significance of being
an attribute identification. Its item 1 is the connected
object, its item 2 is the block qualification C. It follows
that a connection block acts as if its local quantities are
those attributes (excluding labels and switches) of the
connected object which are defined at prefix levels outer
to and including that of C. (Name conflicts between
attributes defined at different prefix levels of C are
resolved by selecting the one defined at the innermost
prefix level.)</p>

<p><b>Example</b></p>

<p>Let "Polar" be the class declared in the example of 5.5.2.
Then within the connection-block-2 of the connection
statement</p>
<pre>
    <b>inspect</b> <b>new</b> Polar(4,5) <b>do</b> <b>begin</b> ... <b>end</b>
</pre>
<p>a procedure "plus" is available for vector addition.</p>
</seksjon>

<seksjon tittel="Compound statement">
<pre>
    compound-statement
        =  <b>begin</b>  compound-tail

    compound-tail
        =  statement  { ; statement }  <b>end</b>
</pre>
<p>This syntax may be illustrated as follows: Denoting
arbitrary statements and labels, by the letters S and L,
respectively, the syntactic unit takes the form:</p>
<pre>
       L: L: ... <b>begin</b>  S; S; ... S; S <b>end</b>
</pre>
<p><b>Note</b>: Each of the statements S may be a complete compound
      statement or block.</p>

<p><b>Example</b></p>
<pre>
     <b>begin</b> x:=0;
         <b>for</b> y:=1 <b>step</b> 1 <b>until</b> n <b>do</b> x := x + a(y);
         <b>if</b> x&gt;q <b>then</b> <b>goto</b> stop
         <b>else</b> <b>if</b> x&gt;w-2 <b>then</b> <b>goto</b> s;
 aw: st: w:=x+bob
     <b>end</b>
</pre>
</seksjon>






<seksjon tittel="Blocks">
<pre>
    block
        =  subblock
        |  prefixed-block

    subblock
        =  block-head  ;  compound-tail

    block-head
        =  <b>begin</b>  declaration  { ; declaration }
</pre>
<p>This syntax may be illustrated as follows: Denoting
arbitrary statements, declarations, and labels, by the
letters S, D, and L, respectively, the syntactic unit takes
the form:</p>
<pre>
    L: L: ... <b>begin</b> D; D; ... D; S; S; ... S; S <b>end</b>
</pre>
<p><b>Note</b>: Each of the statements S may be a complete compound
      statement or block.</p>

<p>Every block automatically introduces a new level of
nomenclature. This is realised as follows. Any identifier
occurring within the block may through a suitable
declaration be specified to be local to the block in
question. This means that</p>
<liste indeks="alfa">
<indeks>the entity represented by this identifier inside the
    block has no existence outside it, and</indeks>

<indeks>any entity represented by this identifier outside the
    block is invisible inside the block, unless made visible
    by connection or remote access.</indeks>
</liste>
<p>Identifiers (except those representing labels) occurring
within a block and not being declared to this block will be
non-local to it, i.e. will represent the same entity inside
the block and in the level immediately outside it. A label
separated by a colon from a statement, i.e. labelling that
statement, behaves as though declared in the head of the
smallest embracing block.</p>

<p>A label is said to be implicitly declared in this block
head. In this context, a procedure body, the statement
following a for-clause, or a connection block must be
considered as if it were enclosed by <b>begin</b> and <b>end</b> and
treated as a block, this block being nested within the
fictitious block of 4.6.1 in the case of a procedure with
parameters. A label that is not within any block of the
program (nor within a procedure body, the statement
following a for-clause, or a connection block) is
implicitly declared in the implied connection block
embracing the program.</p>

<p><b>Note</b>: System-defined class identifiers used as prefixes
      within the block as well as identifiers introduced as
      part of an external head are in this respect treated
      in the same manner as labels.</p>

<p>Since a statement of a block may itself be a block the
concepts local and non-local to a block must be understood
recursively. Thus an identifier which is non-local to a
block A may or may not be non-local to the block B in which
A is a statement. See also 5.6.</p>

<p><b>Example</b></p>
<pre>
   Q:  <b>begin</b> integer i, k; real w;
          <b>for</b> i:=1 <b>step</b> -1 <b>until</b> m <b>do</b>
             <b>for</b> k:=i+1 <b>step</b> 1 <b>until</b> m <b>do</b> <b>begin</b>
                w      := A(i,k);
                A(i,k) := A(k,i);
                A(k,i) := w
             <b>end</b> for i and k
       <b>end</b>  block Q
</pre>
<avsnitt tittel="Prefixed blocks">
<pre>
    prefixed-block
        =  block-prefix  main-block

    block-prefix
        =  class-identifier  [ actual-parameter-part ]

    main-block
        =  block
        |  compound-statement
</pre>
<p>An instance of a prefixed block is a compound object whose
prefix part is an object of the class identified by the
block prefix, and whose main part is an instance of the
main block. The formal parameters of the former are
initialised as indicated by the actual parameters of the
block prefix. The concatenation is defined by rules similar
to those of 5.5.2.</p>

<p>The following restrictions must be observed:</p>
<liste indeks="num">
<indeks>A class in which reference is made to the class itself
    through use of <b>this</b> is an illegal block prefix.</indeks>

<indeks>The class identifier of a block prefix must refer to a
    class local to the smallest block enclosing the prefixed
    block (for system-defined class identifiers, see (2) of
    5.5.1).</indeks>
</liste>
<p>A program is enclosed by a prefixed block (cf. chapter 10).</p>

<p><b>Example</b></p>

<p>Let "hashing" be the class declared in the example of
5.5.3. Then within the prefixed block</p>
<pre>
  hashing(64) <b>begin</b>
       <b>integer</b> <b>procedure</b> hash(T); <b>text</b> T;
        ... ;
        ...
  <b>end</b>
</pre>
<p>a "lookup" procedure is available which makes use of the
"hash" procedure declared within the main block.</p>
</avsnitt>
</seksjon>

<seksjon tittel="Dummy statement">
<pre>
    dummy-statement
        =  empty
</pre>
<p>A dummy statement executes no operation. It may serve to
place a label.</p>

<pre>
<p><b>Example</b>L: <b>begin</b> statements; John: <b>end</b>
</p>
</pre>
</seksjon>
</kapittel><kapittel tittel="Chapter 7 - SEQUENCING">
  <seksjon tittel="3.1 Block instances and states of execution">
    <p>
      The constituent parts of a program execution are dynamic 
      instances of blocks, i.e. subblocks, prefixed blocks, 
      connection blocks and class bodies. A block instance is 
      said to be "local to" the one which (directly) contains 
      its describing text. For instance an object of a given 
      class is local to the block instance which contains the 
      class declaration. The instance of the outermost block 
      (see chapter 11) is local to no block instance.
    </p>
    <p>
      The constituent parts of a program execution are dynamic 
      instances of blocks, i.e. subblocks, prefixed blocks, 
      connection blocks and class bodies. A block instance is 
      said to be "local to" the one which (directly) contains 
      its describing text. For instance an object of a given 
      class is local to the block instance which contains the 
      class declaration. The instance of the outermost block 
      (see chapter 11) is local to no block instance.
    </p>
    <p>
      The entry into any block invokes the generation of an 
      instance of that block, whereupon the PSC enters the 
      block instance at its first executable statement. 
      If and when the PSC reaches the final <b>end</b> of a non-class 
      block instance (i.e. an instance of a prefixed block, a 
      subblock, a procedure body or a connection block) the PSC 
      returns to the program point immediately following the 
      statement or expression which caused the generation of 
      the block instance. For sequencing of class objects see 
      7.2 and 7.3.
    </p>
    <p>
      A block instance is at any time in one of four states of 
      execution: "attached", "detached", "resumed" or "terminated".
    </p>
    <p>
      A non-class block instance is always in the attached state. 
      The instance is said to be "attached to" the block instance 
      which caused its generation. Thus, an instance of a procedure 
      body is attached to the block instance containing the 
      corresponding procedure statement or function designator. 
      A non-class, non-procedure block instance is attached to the 
      block instance to which it is local. The outermost block 
      instance (see chapter 11) is attached to no block instance. 
      If and when the PSC leaves a non-class block instance through 
      its final <b>end</b>, or through a goto-statement, the block instance 
      ceases to exist.
    </p>
    <p>
      A class object is initially in the attached state and said to 
      be attached to the block instance containing the corresponding 
      object generator. It may enter the detached state through the 
      execution of a "detach statement" (see 7.3.1). The object may 
      reenter the attached state through the execution of a call 
      statement (see 7.3.2), whereby it becomes attached to the block 
      instance containing the call statement. A detached object may 
      enter the resumed state through the execution of a resume statement 
      (see 7.3.3). If and when the PSC leaves the object through its final 
      end or through a goto statement, the object enters the terminated 
      state. No block instance is attached to a terminated class object.
    </p>
    <p>
      The execution of a program which makes no use of detach, call or 
      resume statements is a simple nested structure of attached block instances.
    </p>
    <p>
      Whenever a block instance ceases to exist, all block instances 
      local or attached to it also cease to exist. The dynamic scope 
      of an object is thus limited by that of its class declaration. 
      The dynamic scope of an array declaration may extend beyond that 
      of the block instance containing the declaration, since the call 
      by reference parameter transmission mode is applicable to arrays.
    </p>
  </seksjon>
  <seksjon tittel="Quasi-parallel systems">
    <p>
      A quasi-parallel system is identified by any instance of a subblock 
      or a prefixed block, containing a local class declaration. The block 
      instance which identifies a system is called the "system head".
    </p>
    <p>
      The outermost block instance (see chapter 11) identifies a system 
      referred to as the "outermost system".
    </p>
    <p>
      A quasi-parallel system consists of "components". In each system 
      one of the components is referred to as the "main component" of 
      the system. The other components are called "object components".
    </p>
    <p>
      A component is a nested structure of block instances one of which, 
      called the "component head", identifies the component. The head 
      of the main component of a system coincides with the system head. 
      The heads of the object components of a system are exactly those 
      detached or resumed objects which are local to the system head.
    </p>
    <p>
      At any time exactly one of the components of a system is said to 
      be "operative". A non-operative component has an associated 
      "reactivation point" which identifies the program point where 
      execution will continue if and when the component is activated.
    </p>
    <p>
      The head of an object component is in the resumed state if and 
      only if the component is operative. Note that the head of the 
      main component of a system is always in the attached state.
    </p>
    <p>
      In addition to system components, a program execution may contain 
      "independent object components" which belong to no particular system. 
      The head of any such component is a detached object which is local 
      to a class object or an instance of a procedure body, i.e. which is 
      not local to a system head. By definition, independent components are 
      always non-operative.
    </p>
    <p>
      The sequencing of components is governed by the detach, call and 
      resume statements, defined in 7.3. All three statements operate 
      with respect to an explicitly or implicitly specified object. The 
      following two sections serve as an informal outline of the effects 
      of these statements.
    </p>
    <avsnitt tittel="Semi-symmetric sequencing: detach - call">
      <p>
        In this section, only components which belong to a quasi-parallel 
        system are considered.
      </p>
      <p>
        Initially, i.e. upon the generation of a system head, the main 
        component is the operative and only component of the system.
      </p>
      <p>
        Non-operative object components of the system are created as described 
        in the previous section, i.e. by detach statements with respect to 
        attached objects local to the system head.
      </p>
      <p>
        Non-operative object components of the system may be activated by 
        call-statements, whereby they lose their component status, as 
        described in the previous section.
      </p>
      <p>
        A non-operative object component of the system may also be 
        reactivated through the execution of a resume statement with 
        respect to its detached head, whereby the PSC is moved to its 
        reactivation point. The head of the component enters the resumed 
        state and the component becomes operative. The previously operative 
        component of the system becomes non-operative and its reactivation 
        point is positioned immediately after the resume statement. If this 
        component is an object component its head enters the detached state.
      </p>
      <p>
       The main component of the system regains operative status through 
       the execution of a detach statement with respect to the resumed head 
       of the currently operative object component, whereby the PSC is moved
       to the reactivation point of the main component. The previously 
       operative component becomes non-operative, its reactivation point
       positioned immediately after the detach statement. The head of this 
       component enters the detached state.
      </p>
      <p>
       Observe the symmetric relationship between a resumer and its resumee, 
       in contrast to that between a caller and its callee.
      </p>
    </avsnitt>
    <avsnitt tittel="Dynamic enclosure and the operating chain">
      <p>
        A block instance X is said to be "dynamically enclosed" by a block 
        instance Y if and only if there exists a sequence of block instances
      </p>
      <p>
        <syntaks>
          <produksjon>
            <alternativ>
              X = Z0, Z1, ...., Zn = Y            (n&gt;=0)
            </alternativ>
          </produksjon>
        </syntaks>
      </p>
      <p>
        such that for i= 1,2,...,n:
      </p>
      <p>
        <punkt>
          <indeks>Zi-1 is attached to Zi, or</indeks>
          <indeks>Zi-1 is a resumed object whose associated system 
          head is attached to Zi.</indeks>
        </punkt>
      </p>
      <p>
        Note that a terminated or detached object is dynamically 
        enclosed by no block instance except itself.
      </p>
      <p>
        The sequence of block instances dynamically enclosing the 
        block instance currently containing the PSC is called the 
        "operating chain". A block instance on the operating chain 
        is said to be "operating". The outermost block instance 
        is always operating.
      </p>
      <p>
        A component is said to be operating if the component head 
        is operating.
      </p>
      <p>
        A system is said to be operating if one of its components 
        is operating. At any time, at most one of the components 
        of a system can be operating. Note that the head of an 
        operating system may be non-operating.
      </p>
      <p>
        An operating component is always operative. If the operative 
        component of a system is non-operating, then the system is 
        also non-operating. In such a system, the operative component 
        is that component which was operating at the time when the 
        system became non-operating, and the one which will be operating 
        if and when the system again becomes operating.
      </p>
      <p>
        Consider a non-operative component C whose reactivation point 
        is contained by the block instance X. Then the following is true:
      </p>
      <p>
        <punkt>
          <indeks>X is dynamically enclosed by the head of C.</indeks>
          <indeks>X dynamically encloses no block instance other than itself.</indeks>
        </punkt>
      </p>
      <p>
        The sequence of block instances dynamically enclosed by the head 
        of C is referred to as the "reactivation chain" of C. All component 
        heads on this chain, except the head of C, identify operative 
        (non-operating) c
      </p>
      <p> 
        See detailed example in 7.4.
      </p>
    </avsnitt>
  </seksjon>
  <seksjon tittel="Quasi-parallel sequencing">
    <p>
      A quasi-parallel system is created through the entry into a subblock 
      or a prefixed block, which contains a local class declaration, whereby 
      the generated instance becomes the head of the new system. Initially, 
      the main component is the operative and only component of the system.
    </p>
    <avsnitt tittel="Detach">
      <p>
        Consider a call of the detach attribute of a block instance X.
      </p>
      <p>
        If X is an instance of a prefixed block the detach statement has no 
        effect. Assume that X is a class object. The following cases arise:
      </p>
      <p>
        <liste>
          <indeks>X is an attached object.
                  If X is not operating the detach statement constitutes an 
                  error. Assume X is operating. The effect of the detach statement is:
                  <punkt>
                    <indeks>X becomes detached and thereby (the head of) a new 
                    non-operative object component, its reactivation point 
                    positioned immediately after the detach statement. As a 
                    consequence, that part of the operating chain which is dynamically 
                    enclosed by X becomes the (non-operating) reactivation chain of X.
                    </indeks>
                    <indeks>The PSC returns to the block instance to which X was 
                    attached and execution continues immediately after the associated 
                    object generator or call statement (see 7.3.2).
                    </indeks>
                  </punkt>
                  If X is local to a system head, the new component becomes a member 
                  of the associated system. It is a consequence of the language 
                  definition that, prior to the execution of the detach statement, 
                  X was dynamically enclosed by the head of the operative component 
                  of this system. The operative component remains operative.
          </indeks>
          <indeks>X is a detached object.
          The detach statement then constitutes an error.</indeks>
          <indeks>
          X is a resumed object.
          X is then (the head of) an operative system component. Let S be the 
          associated system. It is a consequence of the language definition that 
          X must be operating. The effect of the detach statement is:
            <punkt>
              <indeks>X enters the detached state and becomes non-operative, its 
              reactivation point positioned immediately after the detach statement. 
              As a consequence, that part of the operating chain which is dynamically 
              enclosed by X becomes the (non-operating) reactivation chain of X.</indeks>
              <indeks>The PSC is moved to the current reactivation point of the main 
              component of S, whereby this main component becomes operative and operating. 
              As a consequence, all block instances on the reactivation chain of the main 
              component also become operating.</indeks>
            </punkt>
          </indeks>
          <indeks>
              X is a terminated object.
              The detach statement then constitutes an error.
          </indeks>
        </liste>
      </p>
    </avsnitt>
    <avsnitt tittel="Call">
      <p>
      "call" is formally a procedure with one object reference parameter 
      qualified by a fictitious class including all classes. Let Y denote 
      the object referenced by a call statement.
      </p>
      <p>
       Assume Y is a detached object. The effect of the call statement is:
      </p>
      <p>
        <punkt>
          <indeks>Y becomes attached to the block instance containing the 
          call statement, whereby Y loses its status as a component head. 
          As a consequence the system to which Y belongs (if any) loses the 
          associated component.</indeks>
          <indeks>The PSC is moved to the (former) reactivation point of Y. 
          As a consequence, all block instances on the reactivation chain 
          of Y become operating</indeks>
        </punkt>
      </p>
    </avsnitt>
    <avsnitt tittel="Resume">
      <p>
        "resume" is formally a procedure with one object reference 
        parameter qualified by a fictitious class including all classes. 
        Let Y denote the object referenced by a resume statement.
      </p>
      <p>
        If Y is not local to a system head, i.e. if Y is local to a class 
        object or an instance of a procedure body, the resume statement 
        constitutes an error.
      </p>
      <p>
        If Y is terminated or attached, or Y==none, 
        the resume statement constitutes an error.
      </p>
      <p>
        Assume Y is a detached object being (the head of) a non-operative system 
        component. Let S be the associated system and let X denote (the head of) 
        the current operative component of S. It is a consequence of the language 
        definition that X must be operating, and that X is either the main component 
        of S or local to the head of S. The effect of the resume statement is:
      </p>
      <p>
        <punkt>
          <indeks>X becomes non-operative, its reactivation point positioned 
          immediately after the resume statement. As a consequence, that part 
          of the operating chain which is dynamically enclosed by X becomes the 
          (non-operating) reactivation chain of X. If X is an object component 
          its head enters the detached state.</indeks>
          <indeks>The PSC is moved to the reactivation point of Y, whereby Y 
          enters the resumed state and becomes operative and operating. As a 
          consequence, all block instances on the reactivation chain of Y also 
          become operating.</indeks>
        </punkt>
      </p>
    </avsnitt>
    <avsnitt tittel="Object end">
      <p>
        The effect of the PSC passing through the final <b>end</b> of a class object is 
        the same as that of a detach with respect to that object, except that the 
        object becomes terminated, not detached. As a consequence it attains no 
        reactivation point and loses its status as a component head (if it has 
        such status).
      </p>
    </avsnitt>
    <avsnitt tittel="Goto statements">
      <p>
        A designational expression defines a program point within a block instance.
      </p>
      <p>
        Let P denote the program point identified by evaluating the designational 
        expression of a goto-statement, and let X be the block instance containing 
        P. Consider the execution of the goto-statement:
      </p>
      <p>
        <liste>
          <indeks>Let Y denote the block instance currently containing the PSC.</indeks>
          <indeks>If X equals Y the PSC is moved to P.</indeks>
          <indeks>Otherwise, if Y is the outermost block instance the goto- statement constitutes an error</indeks>
          <indeks>Otherwise, the effect is that of the PSC passing through the final <b>end</b> of Y (see 7.3.4) after which the process is immediately repeated from 1).</indeks>
        </liste>
      </p>
      <p>
      See also 4.5
      </p>
    </avsnitt>           
  </seksjon>
  <seksjon tittel="3.1 Annotated example">
    <p>
      <produksjon>
      <tabell>
        <rad>
          <kol>1</kol>
          <kol>begin comment S1;</kol>
        </rad>  
        <rad>
          <kol>2</kol>
          <kol>      ref(C1) X1;</kol>
        </rad>
        <rad>
          <kol>3</kol>
          <kol>class C1;</kol>
        </rad>
        <rad>
          <kol>4</kol>
          <kol>begin procedure P1; detach;</kol>
        </rad>
        <rad>
          <kol>5</kol>
          <kol>P1</kol>
        </rad>
        <rad>
          <kol>6</kol>
          <kol>end C1;</kol>
        </rad>
        <rad>
          <kol>7</kol>
          <kol>ref(C2) X2;</kol>
        </rad>
        <rad>
          <kol>8</kol>
          <kol>class C2;</kol>
        </rad>
        <rad>
          <kol>9</kol>
          <kol>begin procedure P2;</kol>
        </rad>
        <rad>
          <kol>10</kol>
          <kol>begin detach;</kol>
        </rad>
        <rad>
          <kol>11</kol>
          <kol>! - see fig. 7.7;</kol>
        </rad>
        <rad>
          <kol>12</kol>
          <kol>end P2;</kol>
        </rad>
        <rad>
          <kol>13</kol>
          <kol>begin comment system S2;</kol>
        </rad>
        <rad>
          <kol>14</kol>
          <kol> ref(C3) X3;</kol>
        </rad>
        <rad>
          <kol>15</kol>
          <kol>class C3; </kol>
        </rad>
        <rad>
          <kol>16</kol>
          <kol>begin detach;</kol>
        </rad>
        <rad>
          <kol>17</kol>
          <kol>P2</kol>
        </rad>
        <rad>
          <kol>18</kol>
          <kol>end C3;</kol>
        </rad>
        <rad>
          <kol>19</kol>
          <kol>X3:- new C3;</kol>
        </rad>
        <rad>
          <kol>20</kol>
          <kol>resume(X3)</kol>
        </rad>
        <rad>
          <kol>21</kol>
          <kol>end S2</kol>
        </rad>
        <rad>
          <kol>22</kol>
          <kol>end C2;</kol>
        </rad>
        <rad>
          <kol>23</kol>
          <kol>X1:- new C1;</kol>
        </rad>
        <rad>
          <kol>24</kol>
          <kol> X2:- new C2;</kol>
        </rad>
        <rad>
          <kol>25</kol>
          <kol>call(X2) </kol>
        </rad>
        <rad>
          <kol>26</kol>
          <kol>end S1;</kol>
        </rad>
      </tabell>
      </produksjon>
    </p>
  </seksjon>
</kapittel></standard>
